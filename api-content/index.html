{"posts":[{"title":"Html CheckBox 实现全选、取消全选","content":"&lt;!-- html 页面 --&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;CheckBox Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; data-check=&quot;all&quot; /&gt; &lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; data-check=&quot;item&quot; data-id=&quot;1&quot; /&gt; &lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; data-check=&quot;item&quot; data-id=&quot;2&quot; /&gt; &lt;/td&gt; &lt;td&gt;小红&lt;/td&gt; &lt;td&gt;11&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 全选、全不选 var $checkAll = $('input[data-check=all]'), $checkItem = $('input[data-check=item]'), itemCount = $checkItem.length; // 复选框：全选或反选 $checkAll.change(function () { $checkItem.prop('checked', this.checked); }); // 复选框：子元素 $checkItem.change(function () { if (!this.checked) { $checkAll.prop('checked', false); } else { var checkedItemNum = $checkItem.filter(':checked').length; checkedItemNum === itemCount &amp;&amp; $checkAll.prop('checked', true); } }); /** * 获取已选择的数据 * @return {Array} */ function getCheckedData(field = 'id') { var data = []; $('input[data-check=item]:checked').each(function () { data.push($(this).data(field)); }); return data; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://fineninejun.github.io/post/html-checkbox-shi-xian-quan-xuan-qu-xiao-quan-xuan/"},{"title":"前端登录交互明文传输使用base64加密，PHP解密","content":"Base64 加密和解密 base64是通用的加解密方法，JavaScript也有现成的库可以使用，PHP更是有现成函数可用。 前端引用base64加密库，推荐用支持中文的 Base64加密库 数据提交之前，用base64的方法加密： var pwd = '123456'; var pwd_encode = base64.encode(pwd); // 加密 PHP读取数据时，用 base64_decode() 方法就可以解密了 $pwd = str_replace(' ', '+', $pwd); $pwd_decode = base64_decode($pwd); // 解密 base64.js 内容 /* * [hi-base64]{@link https://github.com/emn178/hi-base64} * * @version 0.2.1 * @author Chen, Yi-Cyuan [emn178@gmail.com] * @copyright Chen, Yi-Cyuan 2014-2017 * @license MIT */ /*jslint bitwise: true */ (function () { 'use strict'; var root = typeof window === 'object' ? window : {}; var NODE_JS = !root.HI_BASE64_NO_NODE_JS &amp;&amp; typeof process === 'object' &amp;&amp; process.versions &amp;&amp; process.versions.node; if (NODE_JS) { root = global; } var COMMON_JS = !root.HI_BASE64_NO_COMMON_JS &amp;&amp; typeof module === 'object' &amp;&amp; module.exports; var AMD = typeof define === 'function' &amp;&amp; define.amd; var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(''); var BASE64_DECODE_CHAR = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25, 'a': 26, 'b': 27, 'c': 28, 'd': 29, 'e': 30, 'f': 31, 'g': 32, 'h': 33, 'i': 34, 'j': 35, 'k': 36, 'l': 37, 'm': 38, 'n': 39, 'o': 40, 'p': 41, 'q': 42, 'r': 43, 's': 44, 't': 45, 'u': 46, 'v': 47, 'w': 48, 'x': 49, 'y': 50, 'z': 51, '0': 52, '1': 53, '2': 54, '3': 55, '4': 56, '5': 57, '6': 58, '7': 59, '8': 60, '9': 61, '+': 62, '/': 63, '-': 62, '_': 63 }; var utf8ToBytes = function (str) { var bytes = []; for (var i = 0; i &lt; str.length; i++) { var c = str.charCodeAt(i); if (c &lt; 0x80) { bytes[bytes.length] = c; } else if (c &lt; 0x800) { bytes[bytes.length] = 0xc0 | (c &gt;&gt; 6); bytes[bytes.length] = 0x80 | (c &amp; 0x3f); } else if (c &lt; 0xd800 || c &gt;= 0xe000) { bytes[bytes.length] = 0xe0 | (c &gt;&gt; 12); bytes[bytes.length] = 0x80 | ((c &gt;&gt; 6) &amp; 0x3f); bytes[bytes.length] = 0x80 | (c &amp; 0x3f); } else { c = 0x10000 + (((c &amp; 0x3ff) &lt;&lt; 10) | (str.charCodeAt(++i) &amp; 0x3ff)); bytes[bytes.length] = 0xf0 | (c &gt;&gt; 18); bytes[bytes.length] = 0x80 | ((c &gt;&gt; 12) &amp; 0x3f); bytes[bytes.length] = 0x80 | ((c &gt;&gt; 6) &amp; 0x3f); bytes[bytes.length] = 0x80 | (c &amp; 0x3f); } } return bytes; }; var decodeAsBytes = function (base64Str) { var v1, v2, v3, v4, bytes = [], index = 0, length = base64Str.length; if (base64Str.charAt(length - 2) === '=') { length -= 2; } else if (base64Str.charAt(length - 1) === '=') { length -= 1; } // 4 char to 3 bytes for (var i = 0, count = length &gt;&gt; 2 &lt;&lt; 2; i &lt; count;) { v1 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v2 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v3 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v4 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; bytes[index++] = (v1 &lt;&lt; 2 | v2 &gt;&gt;&gt; 4) &amp; 255; bytes[index++] = (v2 &lt;&lt; 4 | v3 &gt;&gt;&gt; 2) &amp; 255; bytes[index++] = (v3 &lt;&lt; 6 | v4) &amp; 255; } // remain bytes var remain = length - count; if (remain === 2) { v1 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v2 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; bytes[index++] = (v1 &lt;&lt; 2 | v2 &gt;&gt;&gt; 4) &amp; 255; } else if (remain === 3) { v1 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v2 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v3 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; bytes[index++] = (v1 &lt;&lt; 2 | v2 &gt;&gt;&gt; 4) &amp; 255; bytes[index++] = (v2 &lt;&lt; 4 | v3 &gt;&gt;&gt; 2) &amp; 255; } return bytes; }; var encodeFromBytes = function (bytes) { var v1, v2, v3, base64Str = '', length = bytes.length; for (var i = 0, count = parseInt(length / 3) * 3; i &lt; count;) { v1 = bytes[i++]; v2 = bytes[i++]; v3 = bytes[i++]; base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4 | v2 &gt;&gt;&gt; 4) &amp; 63] + BASE64_ENCODE_CHAR[(v2 &lt;&lt; 2 | v3 &gt;&gt;&gt; 6) &amp; 63] + BASE64_ENCODE_CHAR[v3 &amp; 63]; } // remain char var remain = length - count; if (remain === 1) { v1 = bytes[i]; base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4) &amp; 63] + '=='; } else if (remain === 2) { v1 = bytes[i++]; v2 = bytes[i]; base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4 | v2 &gt;&gt;&gt; 4) &amp; 63] + BASE64_ENCODE_CHAR[(v2 &lt;&lt; 2) &amp; 63] + '='; } return base64Str; }; var btoa = root.btoa, atob = root.atob, utf8Base64Encode, utf8Base64Decode; if (NODE_JS) { var Buffer = require('buffer').Buffer; btoa = function (str) { return new Buffer(str, 'ascii').toString('base64'); }; utf8Base64Encode = function (str) { return new Buffer(str).toString('base64'); }; encodeFromBytes = utf8Base64Encode; atob = function (base64Str) { return new Buffer(base64Str, 'base64').toString('ascii'); }; utf8Base64Decode = function (base64Str) { return new Buffer(base64Str, 'base64').toString(); }; } else if (!btoa) { btoa = function (str) { var v1, v2, v3, base64Str = '', length = str.length; for (var i = 0, count = parseInt(length / 3) * 3; i &lt; count;) { v1 = str.charCodeAt(i++); v2 = str.charCodeAt(i++); v3 = str.charCodeAt(i++); base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4 | v2 &gt;&gt;&gt; 4) &amp; 63] + BASE64_ENCODE_CHAR[(v2 &lt;&lt; 2 | v3 &gt;&gt;&gt; 6) &amp; 63] + BASE64_ENCODE_CHAR[v3 &amp; 63]; } // remain char var remain = length - count; if (remain === 1) { v1 = str.charCodeAt(i); base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4) &amp; 63] + '=='; } else if (remain === 2) { v1 = str.charCodeAt(i++); v2 = str.charCodeAt(i); base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4 | v2 &gt;&gt;&gt; 4) &amp; 63] + BASE64_ENCODE_CHAR[(v2 &lt;&lt; 2) &amp; 63] + '='; } return base64Str; }; utf8Base64Encode = function (str) { var v1, v2, v3, base64Str = '', bytes = utf8ToBytes(str), length = bytes.length; for (var i = 0, count = parseInt(length / 3) * 3; i &lt; count;) { v1 = bytes[i++]; v2 = bytes[i++]; v3 = bytes[i++]; base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4 | v2 &gt;&gt;&gt; 4) &amp; 63] + BASE64_ENCODE_CHAR[(v2 &lt;&lt; 2 | v3 &gt;&gt;&gt; 6) &amp; 63] + BASE64_ENCODE_CHAR[v3 &amp; 63]; } // remain char var remain = length - count; if (remain === 1) { v1 = bytes[i]; base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4) &amp; 63] + '=='; } else if (remain === 2) { v1 = bytes[i++]; v2 = bytes[i]; base64Str += BASE64_ENCODE_CHAR[v1 &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[(v1 &lt;&lt; 4 | v2 &gt;&gt;&gt; 4) &amp; 63] + BASE64_ENCODE_CHAR[(v2 &lt;&lt; 2) &amp; 63] + '='; } return base64Str; }; atob = function (base64Str) { var v1, v2, v3, v4, str = '', length = base64Str.length; if (base64Str.charAt(length - 2) === '=') { length -= 2; } else if (base64Str.charAt(length - 1) === '=') { length -= 1; } // 4 char to 3 bytes for (var i = 0, count = length &gt;&gt; 2 &lt;&lt; 2; i &lt; count;) { v1 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v2 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v3 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v4 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; str += String.fromCharCode((v1 &lt;&lt; 2 | v2 &gt;&gt;&gt; 4) &amp; 255) + String.fromCharCode((v2 &lt;&lt; 4 | v3 &gt;&gt;&gt; 2) &amp; 255) + String.fromCharCode((v3 &lt;&lt; 6 | v4) &amp; 255); } // remain bytes var remain = length - count; if (remain === 2) { v1 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v2 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; str += String.fromCharCode((v1 &lt;&lt; 2 | v2 &gt;&gt;&gt; 4) &amp; 255); } else if (remain === 3) { v1 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v2 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; v3 = BASE64_DECODE_CHAR[base64Str.charAt(i++)]; str += String.fromCharCode((v1 &lt;&lt; 2 | v2 &gt;&gt;&gt; 4) &amp; 255) + String.fromCharCode((v2 &lt;&lt; 4 | v3 &gt;&gt;&gt; 2) &amp; 255); } return str; }; utf8Base64Decode = function (base64Str) { var str = '', bytes = decodeAsBytes(base64Str), length = bytes.length; var i = 0, followingChars = 0, b, c; while (i &lt; length) { b = bytes[i++]; if (b &lt;= 0x7F) { str += String.fromCharCode(b); continue; } else if (b &gt; 0xBF &amp;&amp; b &lt;= 0xDF) { c = b &amp; 0x1F; followingChars = 1; } else if (b &lt;= 0xEF) { c = b &amp; 0x0F; followingChars = 2; } else if (b &lt;= 0xF7) { c = b &amp; 0x07; followingChars = 3; } else { throw 'not a UTF-8 string'; } for (var j = 0; j &lt; followingChars; ++j) { b = bytes[i++]; if (b &lt; 0x80 || b &gt; 0xBF) { throw 'not a UTF-8 string'; } c &lt;&lt;= 6; c += b &amp; 0x3F; } if (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDFFF) { throw 'not a UTF-8 string'; } if (c &gt; 0x10FFFF) { throw 'not a UTF-8 string'; } if (c &lt;= 0xFFFF) { str += String.fromCharCode(c); } else { c -= 0x10000; str += String.fromCharCode((c &gt;&gt; 10) + 0xD800); str += String.fromCharCode((c &amp; 0x3FF) + 0xDC00); } } return str; }; } else { utf8Base64Encode = function (str) { var result = ''; for (var i = 0; i &lt; str.length; i++) { var charcode = str.charCodeAt(i); if (charcode &lt; 0x80) { result += String.fromCharCode(charcode); } else if (charcode &lt; 0x800) { result += String.fromCharCode(0xc0 | (charcode &gt;&gt; 6)) + String.fromCharCode(0x80 | (charcode &amp; 0x3f)); } else if (charcode &lt; 0xd800 || charcode &gt;= 0xe000) { result += String.fromCharCode(0xe0 | (charcode &gt;&gt; 12)) + String.fromCharCode(0x80 | ((charcode &gt;&gt; 6) &amp; 0x3f)) + String.fromCharCode(0x80 | (charcode &amp; 0x3f)); } else { charcode = 0x10000 + (((charcode &amp; 0x3ff) &lt;&lt; 10) | (str.charCodeAt(++i) &amp; 0x3ff)); result += String.fromCharCode(0xf0 | (charcode &gt;&gt; 18)) + String.fromCharCode(0x80 | ((charcode &gt;&gt; 12) &amp; 0x3f)) + String.fromCharCode(0x80 | ((charcode &gt;&gt; 6) &amp; 0x3f)) + String.fromCharCode(0x80 | (charcode &amp; 0x3f)); } } return btoa(result); }; utf8Base64Decode = function (base64Str) { var tmpStr = atob(base64Str.trim('=').replace(/-/g, '+').replace(/_/g, '/')); if (!/[^\\x00-\\x7F]/.test(tmpStr)) { return tmpStr; } var str = '', i = 0, length = tmpStr.length, followingChars = 0, b, c; while (i &lt; length) { b = tmpStr.charCodeAt(i++); if (b &lt;= 0x7F) { str += String.fromCharCode(b); continue; } else if (b &gt; 0xBF &amp;&amp; b &lt;= 0xDF) { c = b &amp; 0x1F; followingChars = 1; } else if (b &lt;= 0xEF) { c = b &amp; 0x0F; followingChars = 2; } else if (b &lt;= 0xF7) { c = b &amp; 0x07; followingChars = 3; } else { throw 'not a UTF-8 string'; } for (var j = 0; j &lt; followingChars; ++j) { b = tmpStr.charCodeAt(i++); if (b &lt; 0x80 || b &gt; 0xBF) { throw 'not a UTF-8 string'; } c &lt;&lt;= 6; c += b &amp; 0x3F; } if (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDFFF) { throw 'not a UTF-8 string'; } if (c &gt; 0x10FFFF) { throw 'not a UTF-8 string'; } if (c &lt;= 0xFFFF) { str += String.fromCharCode(c); } else { c -= 0x10000; str += String.fromCharCode((c &gt;&gt; 10) + 0xD800); str += String.fromCharCode((c &amp; 0x3FF) + 0xDC00); } } return str; }; } var encode = function (str, asciiOnly) { var notString = typeof(str) != 'string'; if (notString &amp;&amp; str.constructor === root.ArrayBuffer) { str = new Uint8Array(str); } if (notString) { return encodeFromBytes(str); } else { if (!asciiOnly &amp;&amp; /[^\\x00-\\x7F]/.test(str)) { return utf8Base64Encode(str); } else { return btoa(str); } } }; var decode = function (base64Str, asciiOnly) { return asciiOnly ? atob(base64Str) : utf8Base64Decode(base64Str); }; var exports = { encode: encode, decode: decode, atob: atob, btoa: btoa }; decode.bytes = decodeAsBytes; decode.string = decode; if (COMMON_JS) { module.exports = exports; } else { root.base64 = exports; if(AMD) { define(function() { return exports; }); } } })(); ","link":"https://fineninejun.github.io/post/qian-duan-deng-lu-jiao-hu-ming-wen-chuan-shu-shi-yong-base64-jia-mi-php-jie-mi/"},{"title":"Thinkphp5原生查询分页","content":"最近有个项目用的是 thinkphp V5.0.0 , 因为需要对字符串进行排序需要用到 mysql 中的 CAST 函数，看了下TP文档，发现 orderRaw 函数，但 orderRaw 需要框架为 V5.0.17+，担心升级框架会对原系统有影响，所以想到了可以用原生查询。 原生查询 Db::query 示例Db::query(&quot;select * from think_user where id=? AND status=?&quot;,[8, 1]); // 或 Db::query(&quot;select * from think_user where id = :id AND status = :status&quot;,[':id' =&gt; 8, ':status' =&gt; 1]); 分页 $page = request()-&gt;param('page'); $page = $page ? $page : 1; // 当前页码 $page_size = 15; // 每页记录个数 $limit = ($page - 1) * $page_size; // 全部记录查询 $all_list_sql = &quot;select * from users where type=1 order by CAST(name as unsigned) asc&quot;; $all_list = Db::query($all_list_sql); // 当前页面记录查询 $cur_list_sql = $all_list_sql . &quot; limit {$limit}, {$page_size}&quot;; $cur_list = Db::query($cur_list_sql); // 总记录数据 $count = count($all_list); // 分页 $list = Bootstrap::make($cur_list, $page_size, $page, $count, false, ['path' =&gt; Bootstrap::getCurrentPath(), 'query' =&gt; request()-&gt;param()]); ","link":"https://fineninejun.github.io/post/thinkphp5-yuan-sheng-cha-xun-fen-ye/"},{"title":"Html文本溢出省略字符","content":"display: -webkit-box; display: -moz-box; white-space: pre-wrap; word-wrap: break-word; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 2; 属性说明 display 定义 设置元素应该生成的框的类型。 可传值 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。 table-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。 table-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;） table-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;） table-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;） inherit 规定应该从父元素继承 display 属性的值。 white-space 定义 设置如何处理元素内的空白。 可传值 值 描述 normal 默认。空白会被浏览器忽略。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承 white-space 属性的值。 word-wrap 定义 设置允许长单词或 URL 地址换行到下一行。 可传值 值 描述 normal 只在允许的断字点换行（浏览器保持默认处理）。 break-word 在长单词或 URL 地址内部进行换行。 overflow 定义 设置当内容溢出元素框时发生的事情。 可传值 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 text-overflow 定义 设置规定当文本溢出包含元素时发生的事情。 可传值 值 描述 clip 修剪文本。 ellipsis 显示省略符号来代表被修剪的文本。 string 使用给定的字符串来代表被修剪的文本。 -webkit-box-orient 定义 设置一个box子元素是否应按水平或垂直排列。 可传值 值 描述 horizontal 指定子元素在一个水平线上从左至右排列 vertical 从顶部向底部垂直布置子元素 inline-axis 子元素沿着内联坐标轴（映射到横向） block-axis 子元素沿着块坐标轴（映射到垂直） inherit box-orient 属性的值应该从父元素继承 -webkit-line-clamp 定义 设置块元素显示的文本的行数。 可传值 值 描述 number 块元素显示的文本的行数 ","link":"https://fineninejun.github.io/post/html-wen-ben-yi-chu-sheng-lue-zi-fu/"},{"title":"Web直传AliyunOss","content":"最近开发的一个项目上传的资源较多，所以用到了阿里云的对象存储。 前面开发了三个版本： 整体上传到本地；（上传时间长，无法监控上传进度，容易出现请求超时的情况） 分片上传到本地；（上传时间缩短，可监控上传进度，文件片段可自由定义，可避免请求超时的情况） 分片上传到本地 =&gt; 将本地文件分片上传到OSS；（需要发出两次上传请求，第一个步骤上传时间缩短，可监控上传进度，文件片段可自由定义，可避免请求超时的情况；第二个步骤上传时间长，无法监控上传进度，容易出现请求超时的情况） web直传到OSS；（上传时间较短，可监控上传进度，文件片段可自由定义，可避免请求超时的情况） 步骤 步骤详情可查看官方文档 https://help.aliyun.com/document_detail/100624.html RAM访问控制 - 权限策略管理 - 新建自定义权限策略 { &quot;Version&quot;: &quot;1&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;oss:DeleteObject&quot;, &quot;oss:ListParts&quot;, &quot;oss:AbortMultipartUpload&quot;, &quot;oss:PutObject&quot;, &quot;oss:GetObject&quot; ], &quot;Resource&quot;: [ &quot;acs:oss:*:*:YourBucketName&quot;, &quot;acs:oss:*:*:YourBucketName/*&quot; ] } ] } 新建 RAM角色 为新增的 RAM角色 添加自定义权限策略 AliyunSTSAssumeRoleAccess 授权 - 获取 ARN 新建子账号 编程访问 - 获取 AccessKeyID 和 AccessKeySecret 为新建的子账号添加调用 STS 服务 AssumeRole 接口的权限 设置跨域规则 来源：设置精准域名（例如 www.aliyun.com ）或带有通配符星号（ * ）的域名（例如 *.aliyun.com ）；此处可设置为 * 允许 Methods ：请根据实际使用场景，选择不同的 Methods 。例如分片上传时，设置为PUT；删除文件时，设置为 DELETE 允许 Headers ：设置为 * 暴露 Headers ：设置为 ETag 、 x-oss-request-id 和 x-oss-version-id 服务端调用 - 获取临时STS授权 前端分片上传OSS 服务端调用 服务端调用详情可查看官方文档 https://help.aliyun.com/document_detail/121136.htm?spm=a2c4g.11186623.0.0.743625beBt6kjB#reference-w5t-25v-xdb 安装官方SDK composer require alibabacloud/sdk PHP后端代码 &lt;?php use AlibabaCloud\\Client\\AlibabaCloud; use AlibabaCloud\\Client\\Exception\\ClientException; use AlibabaCloud\\Client\\Exception\\ServerException; //构建一个阿里云客户端，用于发起请求。 //构建阿里云客户端时需要设置AccessKey ID和AccessKey Secret。 AlibabaCloud::accessKeyClient('&lt;accessKeyId&gt;', '&lt;accessSecret&gt;') -&gt;regionId('cn-hangzhou') -&gt;asDefaultClient(); //设置参数，发起请求。关于参数含义和设置方法，请参见《API参考》。 try { $result = AlibabaCloud::rpc() -&gt;product('Sts') // -&gt;scheme('https') // https | http -&gt;version('2015-04-01') -&gt;action('AssumeRole') -&gt;method('POST') -&gt;host('sts.aliyuncs.com') -&gt;options([ 'query' =&gt; [ 'RegionId' =&gt; &quot;cn-hangzhou&quot;, 'RoleArn' =&gt; &quot;&lt;RoleArn&gt;&quot;, 'RoleSessionName' =&gt; &quot;&lt;RoleSessionName&gt;&quot;, ], ]) -&gt;request(); print_r($result-&gt;toArray()); } catch (ClientException $e) { echo $e-&gt;getErrorMessage() . PHP_EOL; } catch (ServerException $e) { echo $e-&gt;getErrorMessage() . PHP_EOL; } 前端分片上传 前端上传详情可查看官方文档 https://help.aliyun.com/document_detail/32069.html 浏览器引入 &lt;!-- 引入在线资源 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://gosspublic.alicdn.com/aliyun-oss-sdk-6.16.0.min.js&quot;&gt;&lt;/script&gt; 前端代码 &lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById('file').addEventListener('change', function (e) { let file = e.target.files[0]; let storeAs = 'upload-file'; console.log(file.name + ' =&gt; ' + storeAs); // OSS.urlib是SDK内部封装的发送请求的逻辑，开发者可以使用任何发送请求的库向sts-server发送请求。 OSS.urllib.request(&quot;http://your_sts_server/&quot;, {method: 'GET'}, (err, response) =&gt; { if (err) { console.log('err:', err) } let result; try { result = JSON.parse(response); } catch (e) { console.log('parse sts response info error: ' + e.message); } let client = new OSS({ accessKeyId: result.AccessKeyId, accessKeySecret: result.AccessKeySecret, stsToken: result.SecurityToken, // region表示您申请OSS服务所在的地域，例如oss-cn-hangzhou。 region: '&lt;Your region&gt;', bucket: '&lt;Your bucket name&gt;' }); // file_name可以自定义为文件名（例如file.txt）或目录（例如abc/test/file.txt）的形式，实现将文件上传至当前Bucket或Bucket下的指定目录。 // file可以自定义为File对象、Blob数据以及OSS Buffer。 client.multipartUpload(file_name, file, { // 设置并发上传的分片数量。 parallel: 4, // 设置分片大小。默认值为1 MB，最小值为100 KB。 partSize: 1024 * 1024, // 上传进度监控 progress: (p, cpt, res) =&gt; { console.log('progress p', p); //上传进度监控 console.log('progress cpt', cpt); //上传断点 console.log('progress res', res); } }).then(function (result) { console.log('result', result); }).catch(function (err) { console.log('err', err); }); }); }); &lt;/script&gt; &lt;/body&gt; ","link":"https://fineninejun.github.io/post/web-zhi-chuan-aliyunoss1/"},{"title":"layui分片上传超大文件（以上传视频为例）","content":" layui + thinkphp 分片上传超大视频，分片上传的意义在于把一个文件分成多份，一片一片的上传。当某一片上传失败时可以记录下来，进行重传或者其他处理，分片的附带好处还能很方便的实现进度条。 html &lt;div class=&quot;layui-btn-container&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal&quot; id=&quot;upload-video&quot;&gt; 选择视频&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;&quot; id=&quot;uploadVideoView&quot;&gt; &lt;!--分片上传 - 总片数--&gt; &lt;input type=&quot;hidden&quot; id=&quot;totalPage&quot; value=&quot;0&quot;/&gt; &lt;!--分片上传 - 当前片数--&gt; &lt;input type=&quot;hidden&quot; id=&quot;page&quot; value=&quot;1&quot;/&gt; &lt;!--分片上传 - 状态值--&gt; &lt;input type=&quot;hidden&quot; id=&quot;status&quot; value=&quot;0&quot;/&gt; &lt;div&gt; &lt;!-- 视频名称 --&gt; &lt;div class=&quot;video-item&quot; id=&quot;videoName&quot;&gt;&lt;/div&gt; &lt;!-- 视频状态 --&gt; &lt;div class=&quot;video-item&quot; id=&quot;videoStatus&quot;&gt; &lt;div id=&quot;video-upload-status&quot; style=&quot;background-color: #5eb95e;&quot;&gt;&lt;/div&gt; &lt;span id=&quot;video-upload-status-text&quot;&gt;已上传&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-hide&quot; id=&quot;videoProgressInfo&quot; style=&quot;padding: 8px 0;&quot;&gt; &lt;!-- 进度条 --&gt; &lt;div style=&quot;width: 240px; display: inline-block;&quot;&gt; &lt;div class=&quot;layui-progress&quot; lay-showperent=&quot;yes&quot; lay-filter=&quot;video&quot;&gt; &lt;div class=&quot;layui-progress-bar&quot; lay-percent=&quot;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 进度条数值 --&gt; &lt;div class=&quot;&quot; id=&quot;video-progress-number&quot; style=&quot;display: inline-block;&quot;&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; javascript &lt;script&gt; $(function () { layui.use(['upload', 'element', 'layer'], function () { var $ = layui.jquery, upload = layui.upload, element = layui.element, layer = layui.layer; var video_progress_num_obj = $('#video-progress-number'); // 进度条数值 // 视频上传 upload.render({ elem: '#upload-video', field: 'videoFile', url: &quot;&lt;?= url('upload/video') ?&gt;&quot;, //此处用的是第三方的 http 请求演示，实际使用时改成您自己的上传接口即可。 accept: 'file', acceptMime: 'video/*', auto: false, choose: function (obj) { // 选中文件后 if (files) { // 删除前一个选择文件 delete files[Object.keys(files)[0]] } files = this.files = obj.pushFile(); // 将每次选择的文件追加到文件队列中 if (files) { var first_file = files[Object.keys(files)[0]] // 修改文件名 $('#videoName').html(first_file.name) // 显示进度条 layui.$('#videoProgressInfo').removeClass('layui-hide'); video_progress_num_obj.html('0%') element.progress('video', '0%'); //可配合 layui 进度条元素使用 // 修改上传状态 $('#video-upload-status').css('background-color', '#F37B1D'); $('#video-upload-status-text').html('等待上传'); var data = this.data; var part_size = 10 * 1024 * 1024; // 每片大小 for (var key in files) { var file = files[key]; var total_size = file.size; var total_page = Math.ceil(total_size / part_size); $('#totalPage').val(total_page); $('#page').val('1'); $('#status').val('1'); var fileName = file.name; var fileExt = fileName.substr(fileName.lastIndexOf('.') + 1); fileName = fileName.substr(0, fileName.lastIndexOf('.')); // 分片上传 - 计时器 var progressTimer = setInterval(function () { var totalPage = parseInt($('#totalPage').val()); var page = parseInt($('#page').val()); var status = $('#status').val(); if (parseInt(totalPage) == parseInt(page) &amp;&amp; (parseInt(status) == 2 || parseInt(status) == -1)) { // 计时器停止 - 条件 =&gt; 1.最后一片完成时；2.状态为完成2时或者状态为失败-1时 clearInterval(progressTimer); } else { if (status == 1) { $('#status').val('0'); data.fileName = fileName; data.originFileName = file.name; data.page = page; data.totalPage = totalPage; data.fileExt = fileExt; obj.upload(key, file.slice((page - 1) * part_size, page * part_size)); } } }, 100); } } }, done: function (res) { // 提交上传后 // console.log(res) if (res.code == 1) { //分片上传 var page = parseInt($('#page').val()); var totalPage = parseInt($('#totalPage').val()); video_progress_num_obj.html(Math.ceil(page * 100 / totalPage) + '%') element.progress('video', Math.ceil(page * 100 / totalPage) + '%'); page = page + 1; $('#page').val(page); $('#status').val('1'); } else if (res.code == 2) { //上传完成 video_progress_num_obj.html('100%') element.progress('video', '100%'); $('#status').val('2'); // 标记完成，使计时器停止 layui.$('#video_id').val(res.data.file_id) layer.msg('上传成功', {time: 1000, anim: 0}, function () { layui.$('#video_id').val(res.data.file_id) $('#video-upload-status').css('background-color', '#5eb95e'); $('#video-upload-status-text').html('上传完成'); }); } else { //上传错误 $('#status').val('-1'); video_progress_num_obj.html('0%') element.progress('video', '0%'); layer.msg(&quot;上传失败，请重试&quot;, {time: 1000, anim: 0}, function () { $('#video-upload-status').css('background-color', '#dd514c'); $('#video-upload-status-text').html('上传失败'); }); } } }); }); }); &lt;/script&gt; php &lt;?php class Upload extends Controller { public function video(Request $request) { $file = $request-&gt;file('videoFile'); $file_name = $request-&gt;param('fileName'); $file_ext = $request-&gt;param('fileExt'); $total_page = $request-&gt;param('totalPage'); $page = $request-&gt;param('page'); $uploaddir = 'uploads/temp/'; if (!is_dir($uploaddir)) { mkdir($uploaddir, 0777, true); } //上传文件要保存的路径 $fname = sprintf($uploaddir . '%s.%s', md5($file_name), $file_ext); try { $data = file_get_contents($file-&gt;getInfo('tmp_name')); if ($page == 1) { file_put_contents($fname, $data); } else { //其余文件追加到文件末尾 file_put_contents($fname, $data, FILE_APPEND); } //最后一片文件 if ($total_page == $page) { // 上传成功 // 删除缓存文件 @unlink($fname); //返回上传状态 return json(['code' =&gt; 2, 'msg' =&gt; '上传成功', 'file_url'=&gt;$fname]); } else { // 分片上传 //返回上传状态 return json(['code' =&gt; 1, 'msg' =&gt; '分片上传成功']); } } catch (Exception $e) { // 删除缓存文件 @unlink($fname); return json(['code' =&gt; 0, 'data' =&gt; ['error' =&gt; $e-&gt;getMessage()]]); } } } ","link":"https://fineninejun.github.io/post/layui-fen-pian-shang-chuan-chao-da-wen-jian-yi-shi-pin-wei-li/"},{"title":"宝塔面板安装 xlsxwriter 扩展","content":" xlsxwriter 是一个 PHP C 扩展，可用于将文本、数字、公式和超链接写入 Excel 2007 + XLSX 文件中的多个工作表。 点击查看文档 wget https://pecl.php.net/get/xlswriter-1.4.0.tgz tar -zxvf xlswriter-1.4.0.tgz cd xlswriter-1.4.0/ /www/server/php/73/bin/phpize ./configure --with-php-config=/www/server/php/73/bin/php-config --enable-reader make &amp;&amp; make install echo &quot;extension = xlswriter.so&quot; &gt;&gt; /www/server/php/73/etc/php.ini /etc/init.d/php-fpm-73 reload /www/server/php/73/bin/php -m|grep -i xlswriter ","link":"https://fineninejun.github.io/post/bao-ta-mian-ban-an-zhuang-xlsxwriter-kuo-zhan/"},{"title":"宝塔面板安装 sqlsrv 扩展","content":" 宝塔面板安装 sqlsrv 扩展，php=7.3 加入源 curl https://packages.microsoft.com/config/rhel/7/prod.repo &gt; /etc/yum.repos.d/mssqlrelease.repo 当前安装的版本为 php7.3 及以上的，如果发现这个链接失效了或者你需要其他版本的，可以到https://packages.microsoft.com/config/rhel/ (opens new window) 安装驱动 yum install msodbcsql mssql-tools unixODBC-devel 下载 pdo_sqlsrv 扩展包 wget http://pecl.php.net/get/pdo_sqlsrv-5.8.1.tgz 更多版本：http://pecl.php.net/package/pdo_sqlsrv (opens new window) 安装 pdo_sqlsrv 扩展 解压扩展包 tar -zxvf pdo_sqlsrv-5.8.1.tgz cd pdo_sqlsrv-5.8.1 编译安装 /www/server/php/73/bin/phpize ./configure --with-php-config=/www/server/php/73/bin/php-config make &amp;&amp; make install 添加到 php.ini 将扩展添加到 php.ini echo &quot;extension = pdo_sqlsrv.so&quot; &gt;&gt; /www/server/php/73/etc/php.ini 重启 php-fpm /etc/init.d/php-fpm-73 reload 检查扩展安装状态或者可以进入phpinfo()中查看 /www/server/php/73/bin/php -m|grep -i sqlsrv 清理安装包 cd .. rm -rf pdo_sqlsrv-5.8.1 rm -rf pdo_sqlsrv-5.8.1.tgz ","link":"https://fineninejun.github.io/post/bao-ta-mian-ban-an-zhuang-sqlsrv-kuo-zhan/"},{"title":"PHP 过滤特殊符号","content":" 过滤特殊字符，仅保留中文、字母、数字、下划线 &lt;?php // 过滤特殊字符，仅保留中文、字母、数字、下划线 function match_chinese($chars, $encoding = 'utf8') { $pattern = ($encoding == 'utf8') ? '/[\\x{4e00}-\\x{9fa5}a-zA-Z0-9_]/u' : '/[\\x80-\\xFF]/'; preg_match_all($pattern, $chars, $result); $temp = join('', $result[0]); return $temp; } ","link":"https://fineninejun.github.io/post/php-guo-lu-te-shu-fu-hao/"},{"title":"使用 wkhtmltopdf和 pdf-merge 实现 Html 转 Pdf","content":" 源于一个通过 html 转 pdf 的一个需求。 安装 wkhtmltopdf windows 上使用 wkhtmltopdf 在 wkhtmltopdf.org/downloads.html 上下载 win 版的安装程序，安装完毕后记录下这两个文件的本地地址 D:\\app\\wkhtmltopdf\\bin\\wkhtmltopdf D:\\app\\wkhtmltopdf\\bin\\wkhtmltoimage 在 CentOS 7 上安装 wkhtmltopdf 在 CentOS 上安装是最花费我时间的。建议在官网上下载（rpm 格式）然后上传至服务器，（期间试过多种方式，这种是一次性成功的）然后执行： rpm -Uvh wkhtmltox-0.12.6-1.centos7.x86_64.rpm 或 rpm -ivh wkhtmltox-0.12.6-1.centos7.x86_64.rpm 安装完成后，查找一下安装路径（一般为 /usr/local/bin） whereis wkhtmltopdf 然后执行命令: sudo chmod +x /usr/local/bin/wkhtmltopdf pdf出现乱码 解决方法：复制 C:\\Windows\\Fonts\\simsun.ttc(宋体) 上传到服务器 /usr/share/fonts/simsun.ttc . 至此，安装完毕。 其实对于一般的 html 转 pdf 来说使用 wkhtmltopdf 就已经足够了。 但对于我当前的需求来说，wkhtmltopdf 提供的边距设置 --margin-x 无法满足我的需求设置，当四边距设置为 0mm 时，封面和尾页可以实现填充页面，当页眉页脚无法显示；当设置边距让页眉页脚显示，封面和尾页又无法填充页面。 所以最后决定将封面和尾页的 pdf 文件和 wkhtmltopdf 生成的内容合并 安装 pdf-merger: 这里我使用的时 jurosh/pdf-merge (2.1.0) 安装： composer require jurosh/pdf-merge 添加依赖项： &quot;jurosh/pdf-merge&quot;: &quot;^2.0&quot; wkhtmltopdf 生成 pdf 文件 相关配置 --enable-local-file-access ： 允许加载本地文件 --encoding &lt;UTF-8&gt; : 设置编码 --page-size &lt;A4&gt; : 设置页面尺寸 --margin-bottom &lt;10mm&gt; : 下边距 --margin-left &lt;0mm&gt; : 左边距 --margin-right &lt;0mm&gt; : 右边距 --margin-top &lt;22mm&gt; : 上边距 --header-html &lt;url&gt; : 页眉链接 --footer-html &lt;url&gt; : 页脚链接 --xsl-style-sheet &lt;url&gt; : 自定义目录 合并 pdf // and now we can use library $pdf = new \\Jurosh\\PDFMerge\\PDFMerger; // add as many pdfs as you want $pdf-&gt;addPDF('path/to/source/file.pdf', 'all', 'vertical') -&gt;addPDF('path/to/source/file1.pdf', 'all') -&gt;addPDF('path/to/source/file2.pdf', 'all', 'horizontal'); // call merge, output format `file` $pdf-&gt;merge('file', 'path/to/export/dir/file.pdf'); ","link":"https://fineninejun.github.io/post/shi-yong-wkhtmltopdf-he-pdf-merge-shi-xian-html-zhuan-pdf/"},{"title":"初识触发器","content":" 触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。 CREATE DEFINER=`codeigniter01`@`localhost` TRIGGER `update_class_name` BEFORE UPDATE ON `test` FOR EACH ROW BEGIN DECLARE class_name VARCHAR(20) DEFAULT ''; set class_name = (SELECT class from `class` where id=new.class_id); set new.class_name=class_name; END; 在 test 表更新前触发，根据 class_id 到 class 表中查询 class 字段，更新到 test 表中的 class_name 如果触发的操作是修改本表数据时，修改需要用一下语句，否则会造成循环调用： set new.class_name='A班'; 修改其他表数据时的语句： update `表名` set NEW.列名 = '列值' where '条件'; ","link":"https://fineninejun.github.io/post/chu-shi-hong-fa-qi/"},{"title":"vue cli4引入vant并配置自动rem换算 postcss-pxtorem和lib-flexible + 黑名单","content":" 在引入 vant 的时候，我看到官方推荐了两个自动转换 px 为 rem 的插件，一个叫 postcss-pxtorem ，一个叫 lib-flexible 。 安装插件 安装 postcss-pxtorem npm install postcss-pxtorem --save-dev 安装 lib-flexible，由于时间的问题， lib-flexible 其实已经弃用了，现在是使用名为 amfe-flexible 的插件， amfe-flexible 实际上就是在 lib-flexible 的基础上更新的，所以用法都是一样。 npm i -s amfe-flexible 安装完毕只需要引入amfe-flexible 引入插件 main.js 文件引入： import 'amfe-flexible' 创建配置文件 在根目录，和 package.json 同级，创建一个名为 postcss.config.js 的文件，然后里面的内容我直接照搬 vant 提供的。 如果有这个文件，可以自行修改里面的内容，没有才创建。 module.exports = { plugins: { autoprefixer: { browsers: ['Android &gt;= 4.0', 'iOS &gt;= 8'], }, 'postcss-pxtorem': { rootValue: 37.5, propList: ['*'], }, }, }; 然后保存，这个时候我们再去 vue 里面，对元素设置 px，运行时会发现网页上自动转换成了 rem 单位。 百度到一个新的配置 module.exports = { plugins: { 'autoprefixer': { overrideBrowserslist: [ 'Android 4.1', 'iOS 7.1', 'Chrome &gt; 31', 'ff &gt; 31', 'ie &gt;= 8' ] }, 'postcss-pxtorem': { rootValue: 37.5, propList: ['*'] } } } 黑名单 顾名思义，在黑名单中的类名，将不会自动 rem 转换 module.exports = { plugins: { 'autoprefixer': { overrideBrowserslist: [ 'Android 4.1', 'iOS 7.1', 'Chrome &gt; 31', 'ff &gt; 31', 'ie &gt;= 8' ] }, 'postcss-pxtorem': { rootValue: 37.5, propList: ['*'], selectorBlackList: ['.van-notify',], } } } ","link":"https://fineninejun.github.io/post/vue-cli4-yin-ru-vant-bing-pei-zhi-zi-dong-rem-huan-suan-postcss-pxtorem-he-lib-flexibl-hei-ming-dan/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://fineninejun.github.io/post/hello-gridea/"}]}